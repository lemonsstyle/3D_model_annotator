<!DOCTYPE html>
<html>
<head>
    <title>PLY加载测试</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container { width: 100%; height: 100vh; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            max-width: 400px;
            max-height: 200px;
            overflow: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">PLY模型加载测试</div>
    <div id="container"></div>
    <div id="debug"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/PLYLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 调试信息输出函数
        function log(message) {
            console.log(message);
            const debug = document.getElementById('debug');
            const line = document.createElement('div');
            line.textContent = message;
            debug.appendChild(line);
            debug.scrollTop = debug.scrollHeight;
        }

        // 初始化场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        // 添加相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // 添加轨道控制
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // 添加灯光
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 获取URL参数
        const urlParams = new URLSearchParams(window.location.search);
        const modelUrl = urlParams.get('model');

        if (modelUrl) {
            log(`准备加载模型: ${modelUrl}`);
            
            // 加载PLY模型
            const loader = new THREE.PLYLoader();
            
            // 使用fetch检查文件是否可访问
            fetch(modelUrl, { method: 'HEAD' })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误 ${response.status}: ${response.statusText}`);
                    }
                    log(`文件检查成功，大小: ${response.headers.get('content-length')} 字节`);
                    return true;
                })
                .then(() => {
                    // 加载模型
                    loader.load(
                        modelUrl,
                        function(geometry) {
                            log('模型加载成功，创建网格...');
                            
                            // 检查是否有颜色属性
                            let material;
                            if (geometry.attributes.color) {
                                log('检测到颜色属性，使用顶点颜色');
                                material = new THREE.PointsMaterial({
                                    size: 0.01,
                                    vertexColors: true
                                });
                            } else {
                                log('未检测到颜色属性，使用默认颜色');
                                material = new THREE.PointsMaterial({
                                    size: 0.01,
                                    color: 0x808080
                                });
                            }
                            
                            // 创建点云
                            const points = new THREE.Points(geometry, material);
                            
                            // 居中模型
                            geometry.computeBoundingBox();
                            const boundingBox = geometry.boundingBox;
                            const center = new THREE.Vector3();
                            boundingBox.getCenter(center);
                            points.position.set(-center.x, -center.y, -center.z);
                            
                            // 自动调整相机位置
                            const size = new THREE.Vector3();
                            boundingBox.getSize(size);
                            const maxDim = Math.max(size.x, size.y, size.z);
                            
                            camera.position.set(maxDim, maxDim, maxDim);
                            camera.lookAt(0, 0, 0);
                            
                            // 添加到场景
                            scene.add(points);
                            
                            log(`加载完成。顶点数: ${geometry.attributes.position.count}`);
                        },
                        function(xhr) {
                            const percent = Math.round((xhr.loaded / xhr.total) * 100);
                            log(`加载进度: ${percent}%`);
                        },
                        function(error) {
                            log(`加载错误: ${error.message}`);
                        }
                    );
                })
                .catch(error => {
                    log(`文件检查失败: ${error.message}`);
                });
        } else {
            log('未指定模型URL。请使用?model=路径/到/模型.ply');
        }

        // 窗口大小调整
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html> 